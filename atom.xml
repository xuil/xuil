<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Web Dev Life</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-09T05:55:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS盒模型</title>
    <link href="http://yoursite.com/2016/09/09/css-box-model/"/>
    <id>http://yoursite.com/2016/09/09/css-box-model/</id>
    <published>2016-09-09T03:37:49.000Z</published>
    <updated>2016-09-09T05:55:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><blockquote><p>文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性及这些盒子的位置。<br>在CSS中，这些矩形盒子用盒模型来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界margin edge, 边框边界border edge, 内边距边界padding edge 与 内容边界content edge。 </p></blockquote><p>In the W3C box model, the width of an element gives the width of the content of the box, excluding padding and border.</p><p>In the traditional box model, the width of an element gives the width between the borders of the box, including padding and border.</p><p>By default, all browsers use the W3C box model, with the exception of IE in “Quirks Mode” (IE5.5 Mode), which uses the traditional one.</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><blockquote><p>box-sizing 属性用来改变默认的CSS盒模型对元素宽高的计算方式。这个属性可以用于模拟那些非正确支持标准盒模型的浏览器的表现。</p></blockquote><p>box-sizing: border-box</p><p>box-sizing: content-box</p><p>The first declaration will cause the box sizes to be applied to the border and everything inside it (traditional model)</p><p>the second one will cause the box sizes to be applied to the content only (W3C model).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文档中的每个元素被描绘为矩形盒子。渲染引擎的目的就是判定大小，属性及这些盒子的位置。&lt;br&gt;在CSS中，这
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="旧文摘记" scheme="http://yoursite.com/tags/%E6%97%A7%E6%96%87%E6%91%98%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>什么是RESTful</title>
    <link href="http://yoursite.com/2016/08/29/what-does-restful-really-mean/"/>
    <id>http://yoursite.com/2016/08/29/what-does-restful-really-mean/</id>
    <published>2016-08-29T03:43:33.000Z</published>
    <updated>2016-08-29T03:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="http://www.zcfy.cc" target="_blank" rel="external">众成翻译</a><br>译者：<a href="http://www.zcfy.cc/@poppinlp" target="_blank" rel="external">poppinlp</a><br>链接：<a href="http://www.zcfy.cc/article/1063" target="_blank" rel="external">http://www.zcfy.cc/article/1063</a><br>原文：<a href="https://www.sitepoint.com/what-does-restful-really-mean/" target="_blank" rel="external">https://www.sitepoint.com/what-does-restful-really-mean/</a></p></blockquote><p>上个月我参加了 <a href="https://skillsmatter.com" target="_blank" rel="external">Skillsmatter</a> 的 <a href="https://skillsmatter.com/courses/541-fast-track-to-restful-to-microservices" target="_blank" rel="external">RESTful 微服务培训</a>。在课程中，我们讨论了 REST API 通常可以给网络应用提供什么，并特别讨论了和微服务通讯相关的内容。个人从这次课程中得到的最大收获是，对于 REST 是什么以及它的利弊有了更好的理解。</p><p>在我职业生涯的大部分时候，我专注于移动技术，也就是，作为服务 API 的消费者。我之前认为我使用过的大多数 API 都是 RESTful 的，但现在我觉得它们 99% 都和 RESTful 相距甚远（因为服务端添加了一些东西，导致客户端崩溃，这听起来很耳熟吧？）。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>REST 这个术语表示 “REpresentational State Transfer”。它的一个可能的正式定义如下：</p><blockquote><p>基于在客户端和服务端之间转移状态（文档），从而使得应用程序状态产生进展的结构化 API 风格。<br>Architectural API style based on transferring a representation of state (documents) between client and server in order to progress the state of an application.</p></blockquote><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>如果希望应用是 RESTful 的，那么需要遵守下面 REST 的约束。遵守这些约束可以使得分布式超媒体系统拥有下列令人激动的非功能性特性：性能优良、可伸缩性、简易性、可扩展性、可视性、可移植性和可靠性。</p><ul><li>客户端-服务端</li></ul><p>CS 模型利于分离关注点。客户端可以不用关注数据储存，因此，客户端的代码可以有很好的<em>移植性</em>。另一方面，服务端不用关注用户界面和用户状态，使得服务端更加<em>简洁</em>和<em>可伸缩</em>。服务端和客户端只要符合已经定义的协议，便可独立开发。</p><ul><li>无状态</li></ul><p>在不同请求间，客户端的上下文不会保存在服务端。每个请求都需要带上所需的全部数据。无状态的服务端使得服务器可以及时回收资源，使得实现更加简洁并且<em>可伸缩</em>。<em>可靠性</em>使得从部分错误中恢复变得容易。<em>可视性</em>指的是监控系统不必超出某个单独的请求就能确定该请求的性质。</p><p>无状态服务端的一个缺点是，因为每次请求都发送了所有需要的数据，那么会降低一点网络性能。</p><ul><li>可缓存的</li></ul><p>REST 应用是个网络系统，因此客户端和中间层可以缓存响应。响应本身需要被定义为可缓存的，如果不是的话，那么需要禁止客户端重用以前的数据，这会降低<em>可靠性</em>。如果缓存中的旧数据和本应产生的数据显著不同，那么请求应该给服务端。缓存可以减少一些服务端和客户端的交互，因此能提高<em>可伸缩性</em>和<em>效率</em>，并且因为降低了平均延迟，所以产生用户可感知的<em>性能</em>提升。</p><ul><li>统一接口</li></ul><p>使用统一接口可以让结构简化并且解耦，有利于不同部分独立的升级。后文中会介绍的URI、资源和超媒体可以构造一个标准的接口，提升交互的<em>可视性</em>，<em>简化</em>整个系统结构以及有利于独立开发。但作为代价的是，因为信息是按照一个标准格式传输，而不是应用需要的特定数据，这使得<em>效率</em>方面有点降低。</p><ul><li>分层系统</li></ul><p>使用分层系统可以通过限制组件的行为来降低复杂性，例如每个元素的权限不能超越其直接层。通过限制系统其他部分的消息，有利于底层的独立性。层可以封装以前的组件，并使新服务和以前的客户端分离。中间层可以通过网络负载均衡来提高<em>可伸缩性</em>。分层系统的主要代价是对于数据处理增加了一些开销和延迟，因此降低了用户可感知的<em>性能</em>。</p><ul><li>按需代码（可选）</li></ul><p>REST 允许客户端通过下载并执行脚本代码来扩展它们的功能。这<em>简化</em>了客户端并提高了<em>可扩展性</em>。另一方面，它降低了<em>可视性</em>，这也是为什么这是非必须的约束。</p><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p>REST 有一些常用的用于构建无状态、可伸缩并且简单的网络 API 的元素。</p><ul><li><p>HTTP</p></li><li><p>Resources</p></li><li><p>URIs</p></li><li><p>Hypermedia</p></li></ul><h3 id="HTTP-文档传输应用协议"><a href="#HTTP-文档传输应用协议" class="headerlink" title="HTTP - 文档传输应用协议"></a>HTTP - 文档传输应用协议</h3><p>因为 HTTP 的一些优势，REST 通常使用 HTTP 作为传输协议。它包括 HTTP 动词、状态码和头部信息。</p><h4 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h4><p>不同于在我们的网络服务中对每个可能的操作定义一堆新的动词，HTTP 定义了一系列标准的动词用于以相同的方式处理相似的场景，从而移除不必要的变量并创建一个更加可懂的 API。每个动词包含两个属性的不同的组合，从而使得它们适用于不同的场景。</p><ul><li>幂等</li></ul><blockquote><p>在失败的时候，操作可以被重复</p></blockquote><ul><li>安全</li></ul><blockquote><p>操作由客户端负责，无副作用</p></blockquote><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>通常用于从服务端读取状态。是个<strong>安全</strong>操作，执行多次并没有修改和污染数据的风险，因为执行一次和执行十次的影响是一样的。同时作为一个<strong>幂等</strong>操作，对于相同的多次请求的结果和一次请求是一样的。</p><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>通常用于在服务端创建状态。它<strong>既不安全也不幂等</strong>。因此多个请求将会在服务器上创建多个资源。作为一个不幂等的操作，POST 不应该用于处理和金钱相关的操作，例如如果付款请求失败了多次，那么我们可能潜在的消费了多次。</p><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p>通常用于在服务端更新状态，也可以用来创建状态。它是<strong>幂等</strong>的，但<strong>不安全</strong>，因为它修改了服务端的状态。由于 PUT 是幂等的，使得它成为与金钱相关操作的一个不错的选择。</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>通常用于在服务端删除状态。它是<strong>幂等</strong>的，但<strong>不安全</strong>，因为它在服务端删除了状态。它的幂等在于删除之前已经删除的状态不会产生进一步的影响。</p><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="external">HTTP 状态码</a>提供了对于请求资源的响应状态的元数据。它们是使得网络成为分布式系统的平台的一部分。它们分为以下几个类别：</p><ul><li><p><code>1xx</code> – 元数据</p></li><li><p><code>2xx</code> – 成功</p></li><li><p><code>3xx</code> – 重定向</p></li><li><p><code>4xx</code> – 客户端错误</p></li><li><p><code>5xx</code> – 服务端错误</p></li></ul><h4 id="头信息"><a href="#头信息" class="headerlink" title="头信息"></a>头信息</h4><p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="external">HTTP 头</a> 是请求和响应中用于传输额外信息的地方。头信息由一堆大小写不敏感的名字后面跟着冒号和它的值组成。头信息可以分组为：</p><ul><li><p>普通头信息：可用于请求和响应，但和主体中传输的数据没有关联。</p></li><li><p>请求头信息：包含关于发送请求的客户端或者抓取的资源相关的更多信息。</p></li><li><p>响应头信息：包含响应相关的额外信息。</p></li><li><p>实体头信息：关于主体中实体的信息，例如 content-length 或者 MIME-type。</p></li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是系统暴露出来的任何含有身份的东西。资源提供了客户端和应用域的关联方式。一张图片、一个电子表格、一个服务或者一个其他资源的集合这些都是资源。资源的获取和发送通过一定的表现形式（例如 XML、JSON 等）。</p><p>根据 “Pass-by-value” 的观点，我们处理资源的表现形式，而不是资源本身。遵循之前 REST 的定义，资源表示为那些网络间传递的文档，以完成工作。服务端关注资源状态，因为它表现了域状态，客户端只是抓取或者发送资源的表现形式以更新应用状态。另一方面，客户端关注应用状态，因为它表现了达到应用程序特定目标的过程。</p><p>资源应该被命名为名词，因为它们代表了系统域特定的概念并且可以通过 URI 来定位。</p><h3 id="URI（统一资源标识符）"><a href="#URI（统一资源标识符）" class="headerlink" title="URI（统一资源标识符）"></a>URI（统一资源标识符）</h3><p>URI 可以区分各个资源。为了获取并且修改某个资源，那么它至少需要一个访问方式。这个方式由 <code>protocol</code> + <code>host</code> + <code>path</code> 组成。</p><p>客户端不应该与特定的资源 URI 关联，因为它们可以在服务端被修改。这也就是超媒体最大的优势，因为它提供了解除客户端和特定 URI 关联的方式，并且为应用协议添加了语义。</p><h3 id="超媒体"><a href="#超媒体" class="headerlink" title="超媒体"></a>超媒体</h3><p>超媒体通过在响应中使用超媒体控制信息（链接和表格），来通知客户端下一步可以做什么，以及在哪个 URI 去做。特定应用中具体的超媒体信息格式在应用的媒体类型中定义。</p><p>超媒体链接由用于指定 URI 来获取链接资源的 <code>href</code> 属性和用于定义关系的意义，从而为应用中状态的转移添加语义的 <code>rel</code> 属性组成。链接的使用允许服务端在不破坏现有客户端的基础上，通过在响应中包含新的链接来推广新的特性。当服务端继续维持之前的响应中的链接，客户端便会像新的状态被添加进来之前一样。直到客户端需要使用新的状态，才需要升级。另一个超媒体的好处是它通过提供一种创建可发现并且自记录的协议引入了可发现性（discoverability）。</p><p>客户端通过固定的 URL 开始与应用交互，从此开始，之后客户端的所有行为遵循服务端在响应中提供的通过媒体类型格式化的链接。</p><p>媒体类型和链接定义了应用服务端与客户端之间的协议。客户端通过使用链接，操纵应用的状态，从而与系统交互。这就是<strong>HATEOAS</strong>（超媒体作为应用状态的引擎）真正的意思。</p><p>超媒体（除了已经定义的元素）是 RESTful 真正的意义。</p><h3 id="Richardson-成熟度模型"><a href="#Richardson-成熟度模型" class="headerlink" title="Richardson 成熟度模型"></a>Richardson 成熟度模型</h3><p>这个模型对于我理解什么是 REST 以及如何解释一个网络应用的属性提供了很大的帮助。它将 REST 系统的组件分成了 3 个等级，并且提供一种理解 RESTful 思想的观点、概念和优势的方法。我觉得相对于一个评估机制，它更像是一个教育模式。</p><p>关于 Richardson 成熟度模型比较详细的解释可以在 <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="external">Martin Fowler 的博客</a>中找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;http://www.zcfy.cc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;众成翻译&lt;/a&gt;&lt;br&gt;译者：&lt;a href=&quot;http://www.zcfy.cc/@poppinlp&quot; targ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS Flex属性</title>
    <link href="http://yoursite.com/2016/08/24/css-flex-attribute/"/>
    <id>http://yoursite.com/2016/08/24/css-flex-attribute/</id>
    <published>2016-08-24T09:10:12.000Z</published>
    <updated>2016-08-26T02:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS flex 属性是一个简写属性，它定义元素在容器中的伸缩行为。flex元素可以根据他们的flex-grow 因子拉伸以填充可用空间，或根据他们的 flex-shrink 因子收缩以防止溢出。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>flex：none | [flex-grow flex-shrink flex-basis]</p><h5 id="取值："><a href="#取值：" class="headerlink" title="取值："></a>取值：</h5><p><strong>none</strong>：</p><p>none关键字的计算值为: 0 0 auto</p><p><strong>flex-grow</strong>：</p><p>用来指定扩展比率。剩余空间是正值时此flex子项相对于flex容器里其他flex子项能分配到空间比例。<br>在flex属性中该值如果被省略则默认为1。</p><p><strong>flex-shrink</strong>：</p><p>用来指定收缩比率。剩余空间是负值时此flex子项相对于flex容器里其他flex子项能收缩的空间比例。<br>在收缩的时候收缩比率会以伸缩基准值加权。<br>在flex属性中该值如果被省略则默认为1。</p><p><strong>flex-basis</strong>：</p><p>用来指定伸缩基准值。在根据伸缩比率计算出剩余空间的分布之前，flex子项长度的起始数值。<br>flex属性中该值如果被省略则默认为0%。<br>flex属性中该值如果被指定为auto，则伸缩基准值的计算值是自身的width设置；如果自身的宽度没有定义，则长度取决于内容。</p><a id="more"></a><h5 id="缩写说明："><a href="#缩写说明：" class="headerlink" title="缩写说明："></a>缩写说明：</h5><p>flex: 1, 其计算值为1 1 0%<br>flex: auto, 其计算值为1 1 auto<br>flex: none, 则其计算值为0 0 auto<br>flex: 0 auto或者flex: initial, 其计算值为0 1 auto，即flex初始值</p><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">.flex&#123;display:flex;width:800px;margin:0;padding:0;list-style:none;&#125;</div><div class="line">.flex :nth-child(1)&#123;flex:1 1 300px;&#125;</div><div class="line">.flex :nth-child(2)&#123;flex:2 2 200px;&#125;</div><div class="line">.flex :nth-child(3)&#123;flex:3 3 400px;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>本例定义了父容器宽（即主轴宽）为800px，由于子元素设置了伸缩基准值flex-basis，相加300+200+400=900，那么子元素将会溢出900-800=100px；<br>由于同时设置了收缩因子，所以加权综合可得300*1+200*2+400*3=1900px；<br>于是我们可以计算a,b,c将被移除的溢出量是多少：<br>a被移除溢出量：(300*1/1900)*100，即约等于16px<br>b被移除溢出量：(200*2/1900)*100，即约等于21px<br>c被移除溢出量：(400*3/1900)*100，即约等于63px<br>最后a,b,c的实际宽度分别为：300-16=284px, 200-21=179px, 400-63=337px</p><p>仍然是上面这个例子，不过将容器的宽度改成了1500px。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">.flex&#123;display:flex;width:1500px;margin:0;padding:0;list-style:none;&#125;</div><div class="line">.flex :nth-child(1)&#123;flex:1 1 300px;&#125;</div><div class="line">.flex :nth-child(2)&#123;flex:2 2 200px;&#125;</div><div class="line">.flex :nth-child(3)&#123;flex:3 3 400px;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"flex"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>本例定义了父容器宽（即主轴宽）为1500px，由于子元素设置了伸缩基准值flex-basis，相加300+200+400=900，那么容器将有1500-900=600px的剩余宽度；我们可以计算a,b,c将被扩展量是多少：<br>a的扩展量：(1/(1+2+3))*600，即约等于100px<br>b的扩展量：(2/(1+2+3))*600，即约等于200px<br>c的扩展量：(3/(1+2+3))*600，即约等于300px<br>最后a,b,c的实际宽度分别为：300+100=400px, 200+200=400px, 400+300=700px</p><p>从本例能看出：<br>当flex-basis在flex属性中不为0时（包括值为auto，此时伸缩基准值等于自身内容宽度），flex子项将分配容器的剩余空间（剩余空间即等于容器宽度减去各项的伸缩基准值）。<br>当flex-basis在flex属性中等于0时，flex子项将分配容器的所有空间（因为各项的伸缩基准值相加等于0，剩余空间等于容器宽度减去各项的伸缩基准值，即减0，最后剩余空间值等于容器宽度），所以可以借助此特性给各子项定义flex: n 来进行按比例均分容器总宽度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS flex 属性是一个简写属性，它定义元素在容器中的伸缩行为。flex元素可以根据他们的flex-grow 因子拉伸以填充可用空间，或根据他们的 flex-shrink 因子收缩以防止溢出。&lt;/p&gt;
&lt;h5 id=&quot;语法：&quot;&gt;&lt;a href=&quot;#语法：&quot; class=&quot;headerlink&quot; title=&quot;语法：&quot;&gt;&lt;/a&gt;语法：&lt;/h5&gt;&lt;p&gt;flex：none | [flex-grow flex-shrink flex-basis]&lt;/p&gt;
&lt;h5 id=&quot;取值：&quot;&gt;&lt;a href=&quot;#取值：&quot; class=&quot;headerlink&quot; title=&quot;取值：&quot;&gt;&lt;/a&gt;取值：&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;none&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;none关键字的计算值为: 0 0 auto&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flex-grow&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用来指定扩展比率。剩余空间是正值时此flex子项相对于flex容器里其他flex子项能分配到空间比例。&lt;br&gt;在flex属性中该值如果被省略则默认为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flex-shrink&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用来指定收缩比率。剩余空间是负值时此flex子项相对于flex容器里其他flex子项能收缩的空间比例。&lt;br&gt;在收缩的时候收缩比率会以伸缩基准值加权。&lt;br&gt;在flex属性中该值如果被省略则默认为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flex-basis&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;用来指定伸缩基准值。在根据伸缩比率计算出剩余空间的分布之前，flex子项长度的起始数值。&lt;br&gt;flex属性中该值如果被省略则默认为0%。&lt;br&gt;flex属性中该值如果被指定为auto，则伸缩基准值的计算值是自身的width设置；如果自身的宽度没有定义，则长度取决于内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS &quot;exactly one root element&quot; 错误排查</title>
    <link href="http://yoursite.com/2015/11/09/angularjs-exactly-one-root-element/"/>
    <id>http://yoursite.com/2015/11/09/angularjs-exactly-one-root-element/</id>
    <published>2015-11-09T03:54:33.000Z</published>
    <updated>2019-04-09T12:59:39.642Z</updated>
    
    <content type="html"><![CDATA[<p>错误提示还是很清楚的，比较诧异的地方是我的模板中并没有多个root element</p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>angularjs为比较老的版本（1.2.2）</p><p>directive设置replace为true</p><p>模板第一行为注释</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">app.directive(&quot;helloWorld&quot;, function() &#123;</div><div class="line">  return &#123;</div><div class="line">    restrict: &quot;A&quot;,</div><div class="line">    template: &quot;&lt;!-- Hello world directive --&gt;&lt;div&gt;Hello world&lt;/div&gt;&quot;,</div><div class="line">    replace: true</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>看下错误提示处的代码，发现并不会对注释做处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//angular代码</div><div class="line">if (directive.replace) &#123;</div><div class="line">    replaceDirective = directive;</div><div class="line">    $template = jqLite(&apos;&lt;div&gt;&apos; +</div><div class="line">                        trim(directiveValue) +</div><div class="line">                    &apos;&lt;/div&gt;&apos;).contents();</div><div class="line">    compileNode = $template[0];</div><div class="line"></div><div class="line">    if ($template.length != 1 || compileNode.nodeType !== 1) &#123;</div><div class="line">        throw $compileMinErr(&apos;tplrt&apos;,</div><div class="line">            &quot;Template for directive &apos;&#123;0&#125;&apos; must have exactly one root element. &#123;1&#125;&quot;,</div><div class="line">            directiveName, &apos;&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>去掉注释</li><li>replace设置为false</li><li>模板再包一层</li><li>升级angularjs（1.3+）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误提示还是很清楚的，比较诧异的地方是我的模板中并没有多个root element&lt;/p&gt;
&lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;angularjs为比较老
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Angularjs" scheme="http://yoursite.com/tags/Angularjs/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS Cookies 操作</title>
    <link href="http://yoursite.com/2015/06/30/angularjs-cookie/"/>
    <id>http://yoursite.com/2015/06/30/angularjs-cookie/</id>
    <published>2015-06-30T03:54:33.000Z</published>
    <updated>2019-04-09T12:58:24.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="cookies"><a href="#cookies" class="headerlink" title="$cookies"></a>$cookies</h4><p>提供浏览器cookies的读/写访问操作。</p><p>需要引入angular-cookies.js文件,ngCookies模块。</p><ul><li>基本方法put/get</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   var app = angular.module(&quot;myApp&quot;, [&apos;ngCookies&apos;]);</div><div class="line"></div><div class="line">   app.controller(&quot;myCtrl&quot;, [&apos;$cookies&apos;, function($cookies) &#123;</div><div class="line">   //set cookie</div><div class="line">$cookies.put(&quot;key&quot;,&quot;value&quot;);</div><div class="line">//get cookie</div><div class="line">$cookies.get(&quot;key&quot;); //value</div><div class="line"></div><div class="line"></div><div class="line">   &#125;]);</div></pre></td></tr></table></figure><ul><li>存取对象，putObject/getObject<br>将Object序列化/反序列化操作后，进行put/get操作，参看源码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">putObject: function(key, value, options) &#123;</div><div class="line">  this.put(key, angular.toJson(value), options);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getObject: function(key) &#123;</div><div class="line">  var value = this.get(key);</div><div class="line">  return value ? angular.fromJson(value) : value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="cookieStore"><a href="#cookieStore" class="headerlink" title="$cookieStore"></a>$cookieStore</h4><p>$cookieStore服务已经不建议使用，其底层使用的就是$cookie的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">get: function(key) &#123;</div><div class="line">  return $cookies.getObject(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">put: function(key, value) &#123;</div><div class="line">  $cookies.putObject(key, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在控制台中使用$cookieStore服务读取cookie时遇到过错误提示，通过上面的分析我们知道是cookie值反序列化时出现了异常，改用$cookie.get解决了问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;cookies&quot;&gt;&lt;a href=&quot;#cookies&quot; class=&quot;headerlink&quot; title=&quot;$cookies&quot;&gt;&lt;/a&gt;$cookies&lt;/h4&gt;&lt;p&gt;提供浏览器cookies的读/写访问操作。&lt;/p&gt;
&lt;p&gt;需要引入angular-cookies
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Angularjs" scheme="http://yoursite.com/tags/Angularjs/"/>
    
  </entry>
  
  <entry>
    <title>CSS规则中浏览器前缀的处理</title>
    <link href="http://yoursite.com/2014/11/24/css-e8-a7-84-e5-88-99-e4-b8-ad-e6-b5-8f-e8-a7-88-e5-99-a8-e5-89-8d-e7-bc-80-e7-9a-84-e5-a4-84-e7-90-86/"/>
    <id>http://yoursite.com/2014/11/24/css-e8-a7-84-e5-88-99-e4-b8-ad-e6-b5-8f-e8-a7-88-e5-99-a8-e5-89-8d-e7-bc-80-e7-9a-84-e5-a4-84-e7-90-86/</id>
    <published>2014-11-24T09:19:51.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、预处理：</p><p>使用CSS预处理语言（如sass），通过定义函数的方式来添加各浏览器前缀：</p><p>sass写法</p><pre>= vendor-prefix($name, $argument)  -webkit-#{$name}: #{$argument}  -ms-#{$name}: #{$argument}  -moz-#{$name}: #{$argument}  -o-#{$name}: #{$argument}  #{$name}: #{$argument}//使用p  +vendor-prefix(hyphens, auto)</pre>scss写法<pre>@mixin vendor-prefix($name, $argument) {  -webkit-#{$name}: #{$argument};  -ms-#{$name}: #{$argument};  -moz-#{$name}: #{$argument};  -o-#{$name}: #{$argument};  #{$name}: #{$argument};}//使用p {  @include vendor-prefix(hyphens, auto)}</pre>处理后的CSS<pre>p {  -webkit-hyphens: auto;  -ms-hyphens: auto;  -moz-hyphens: auto;  -o-hyphens: auto;  hyphens: auto;}</pre>二、后处理：个人而言，我不是很习惯sass的书写方式，不习惯在css（sass）中定义函数，不习惯编译sass文件。我希望可以按着习惯（原生）的方式书写css，然后通过简单的处理做到对各浏览器的兼容（这里仅只添加各浏览器前缀，不包含浏览器hack行为）。下面介绍的autoprefixer插件很好的解决了我上面的需求。autoprefixer通过解析CSS文件中相关属性，添加浏览器前缀到相应规则中。autoprefixer中包含一份[Can I Use ](http://caniuse.com/)数据，通过它来决定需要添加哪些前缀。对应上面的例子，我们在style.css中定义规则<pre>p {  hyphens: auto;}</pre>使用grunt + grunt-autoprefixer处理style.css，Gruntfile.js编写如下：<pre>module.exports = function (grunt) {    grunt.loadNpmTasks('grunt-autoprefixer' );    grunt.initConfig({            autoprefixer: {                options: {                    browsers: ['last 2 versions']                },                single_file: {                    src: 'style.css',                    dest: 'style.output.css'                }            }    });    grunt.registerTask('autoprefix', ['autoprefixer']);}</pre>处理后的style.output.css<pre>p {  -webkit-hyphens: auto;     -moz-hyphens: auto;      -ms-hyphens: auto;          hyphens: auto;}</pre>题外：用grunt注册任务的名称不能同initConfig同名，否则会报错 maximum call stack size exceeded<pre>grunt.registerTask('autoprefixer', ['autoprefixer']); //报错</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、预处理：&lt;/p&gt;
&lt;p&gt;使用CSS预处理语言（如sass），通过定义函数的方式来添加各浏览器前缀：&lt;/p&gt;
&lt;p&gt;sass写法&lt;/p&gt;
&lt;pre&gt;= vendor-prefix($name, $argument)
  -webkit-#{$name}: #{$argum
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="autoprefixer" scheme="http://yoursite.com/tags/autoprefixer/"/>
    
      <category term="sass" scheme="http://yoursite.com/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS中$parse,$interpolate,$compile</title>
    <link href="http://yoursite.com/2014/11/18/angularjs-e4-b8-adparseinterpolatecompile/"/>
    <id>http://yoursite.com/2014/11/18/angularjs-e4-b8-adparseinterpolatecompile/</id>
    <published>2014-11-18T03:54:33.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>三者都可用来进行视图渲染，但在不同的层面提供服务：</p><pre>//示例代码var imgHtml = '![](/path/.)';$scope.name = 'image';$scope.extension = 'jpg';</pre><p>$parse 主要处理单个变量表达式，并能更改变量值（读写服务）。</p><pre>$parse('name')($scope); //-> 'image'$parse('name').assign($scope, 'image2'); // $scope.name -> 'image2' </pre><p>$interpolate 在$parse基础上进行包装，能处理多个变量表达式，但不能更改变量值（只读服务）。</p><pre>$interpolate("/path/.")($scope) // -> 'path/image.jpg'</pre><p>$compile 将字符串转为DOM节点。</p><pre>$compile(imgHtml)($scope) // -> img节点</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三者都可用来进行视图渲染，但在不同的层面提供服务：&lt;/p&gt;
&lt;pre&gt;
//示例代码
var imgHtml = &#39;![](/path/.)&#39;;
$scope.name = &#39;image&#39;;
$scope.extension = &#39;jpg&#39;;
&lt;/pre&gt;

&lt;p&gt;$par
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Angularjs" scheme="http://yoursite.com/tags/Angularjs/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS中Provider,Factory,Service</title>
    <link href="http://yoursite.com/2014/11/17/angularjs-e4-b8-adproviderfactoryservice/"/>
    <id>http://yoursite.com/2014/11/17/angularjs-e4-b8-adproviderfactoryservice/</id>
    <published>2014-11-17T08:14:35.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单来讲，可以使用这三种方法创建服务。其中provider允许在使用前通过config对服务进行配置，而factory和service在angularjs内部都是通过provider实现的。</p><pre>function factory(name, factoryFn) {  return provider(name, { $get: factoryFn });}function service(name, constructor) {  return factory(name, ['$injector', function($injector) {    return $injector.instantiate(constructor);  }]);}</pre>下面是一个具体的使用示例：<pre>var myApp = angular.module('myApp', []);//service style, probably the simplest onemyApp.service('helloWorldFromService', function() {  this.sayHello = function() {    return "Hello, World!"  };});//factory style, more involved but more sophisticatedmyApp.factory('helloWorldFromFactory', function() {  return {    sayHello: function() {      return "Hello, World!"    }  };});//provider style, full blown, configurable versionmyApp.provider('helloWorld', function() {  // In the provider function, you cannot inject any  // service or factory. This can only be done at the  // "$get" method.  this.name = 'Default';  this.$get = function() {    var name = this.name;    return {      sayHello: function() {        return "Hello, " + name + "!"      }    }  };  this.setName = function(name) {    this.name = name;  };});//we can configure a providermyApp.config(function(helloWorldProvider){  helloWorldProvider.setName('World');});function MyCtrl($scope, helloWorld, helloWorldFromFactory, helloWorldFromService) {  $scope.hellos = [    helloWorld.sayHello(),    helloWorldFromFactory.sayHello(),    helloWorldFromService.sayHello()  ];}​</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单来讲，可以使用这三种方法创建服务。其中provider允许在使用前通过config对服务进行配置，而factory和service在angularjs内部都是通过provider实现的。&lt;/p&gt;
&lt;pre&gt;function factory(name, factoryFn
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Angularjs" scheme="http://yoursite.com/tags/Angularjs/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS中$watch和$watchCollection</title>
    <link href="http://yoursite.com/2014/09/28/angularjs-e4-b8-adwatch-e5-92-8cwatchcollection-e7-9a-84-e4-bd-bf-e7-94-a8/"/>
    <id>http://yoursite.com/2014/09/28/angularjs-e4-b8-adwatch-e5-92-8cwatchcollection-e7-9a-84-e4-bd-bf-e7-94-a8/</id>
    <published>2014-09-28T02:03:48.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS中，我们使用$watch方法来监视scope中某个变量的变化。下面是一个简单的例子：</p><p><pre class="“javascript“"><br>function($scope){<br>    $scope.number = 0;<br>    $scope.$watch(‘number’,function(newVal,oldVal){<br>        //当number发生变化的时候执行<br>    })<br>}</pre></p><p><br>对于监视的变量是原始类型（如：数字、字符串），上面的代码可以很好的执行；而如果监视的变量是引用类型（如：对象、数组），上面的代码可能会出现问题。例如：</p><p><pre class="“javascript“"><br>function($scope){<br>    $scope.user = {<br>        name: ‘tom’,<br>        age: 11<br>    };<br>    $scope.$watch(‘user’,function(){<br>        //当给user添加一个属性job时，没有执行<br>    })；<br>    //再看一个例子<br>    $scope.items = [1,2,3];<br>    $scope.$watch(‘items’,function(){<br>        //当给items增加一项时，没有执行<br>    })；</pre></p><p>}</p><p><br>对上面的问题我们要对代码稍作修改：</p><p><pre class="“javascript“"><br>function($scope){<br>    $scope.user = {<br>        name: ‘tom’,<br>        age: 11<br>    };<br>    $scope.$watch(‘user’,function(){<br>        //当给user添加一个属性job时执行<br>    },true)；<br>    //再看一个例子<br>    $scope.items = [1,2,3];<br>    $scope.$watch(‘items’,function(){<br>        //当给items增加一项时执行<br>    },true)；</pre></p><p>}</p><p><br>我们将$watch函数第三个参数设置为true。$watch这第三个参数在默认情况下是false。在默认情况下，我们进行的监视叫做引用监视（reference watch）。它的意思是只要监视的对象引用没有发生变化，就不算它发生了变化。如果我们将$watch的第三个变量设置为true，这时进行的监视叫做全等监视(equality watch)。它在运行时需要先遍历整个监视对象，在每次$digest之前使用angular.copy()将整个对象深拷贝一遍然后用angular.equal()将前后的对象进行对比。</p><p>可以看到全等监视资源开销要大于引用监视，实际场景中要酌情使用。对于数组的监视，angular 1.1.4版本之后添加了一个$watchCollection方法来对监视数组。它的性能介于全等监视和引用监视二者之间，它并不会对数组中每一项的属性进行监视，但是可以对数组的项目的增减做出反应。</p><p><pre class="“javascript“"><br>function($scope){</pre></p><pre><code>$scope.items = [1,2,3];$scope.$watch(&apos;items&apos;,function(){    //当给items增加一项时执行},true)；//使用watchCollection$scope.$watchCollection(&apos;items&apos;,function(){    //当给items增加一项时执行})；</code></pre><p>}</p><p><br>总结，一图胜千言，下面这张图很好的概括了本文介绍的内容。希望本文对使用AngularJS的朋友有所帮助。</p><p><a href="http://phped-wordpress.stor.sinaapp.com/uploads/2014/09/angular_watch_depths1.png" target="_blank" rel="external"><img src="http://phped-wordpress.stor.sinaapp.com/uploads/2014/09/angular_watch_depths1.png" alt="" title="angular_watch_depths"></a></p><div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AngularJS中，我们使用$watch方法来监视scope中某个变量的变化。下面是一个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;“javascript“&quot;&gt;&lt;br&gt;function($scope){&lt;br&gt;    $scope.number = 0;&lt;br&gt; 
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Angularjs" scheme="http://yoursite.com/tags/Angularjs/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Root 密码忘记</title>
    <link href="http://yoursite.com/2013/05/15/mysql-root-e5-af-86-e7-a0-81-e5-bf-98-e8-ae-b0/"/>
    <id>http://yoursite.com/2013/05/15/mysql-root-e5-af-86-e7-a0-81-e5-bf-98-e8-ae-b0/</id>
    <published>2013-05-15T02:11:43.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>依照下面步骤，重新设定root密码：</p><p>环境：Ubuntu</p><ol><li>sudo su -</li><li>/etc/init.d/mysql stop</li><li><strong>/usr/sbin/mysqld –skip-grant-tables –user=root &amp;</strong></li><li>mysql -u root</li><li>mysql&gt; <strong>UPDATE mysql.user SET Password=PASSWORD(‘’) WHERE User=’root’;</strong> # 將 root 密码清掉，也可以重新设置</li><li>mysql&gt; quit</li><li>/etc/init.d/mysql restart # 完成.<br>&nbsp;</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;依照下面步骤，重新设定root密码：&lt;/p&gt;
&lt;p&gt;环境：Ubuntu&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sudo su -&lt;/li&gt;
&lt;li&gt;/etc/init.d/mysql stop&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr/sbin/mysqld –skip-grant-
      
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>转：我眼中的技术高手（有删节）</title>
    <link href="http://yoursite.com/2013/03/20/e8-bd-ac-ef-bc-9a-e6-88-91-e7-9c-bc-e4-b8-ad-e7-9a-84-e6-8a-80-e6-9c-af-e9-ab-98-e6-89-8b-ef-bc-88-e6-9c-89-e5-88-a0-e8-8a-82-ef-bc-89/"/>
    <id>http://yoursite.com/2013/03/20/e8-bd-ac-ef-bc-9a-e6-88-91-e7-9c-bc-e4-b8-ad-e7-9a-84-e6-8a-80-e6-9c-af-e9-ab-98-e6-89-8b-ef-bc-88-e6-9c-89-e5-88-a0-e8-8a-82-ef-bc-89/</id>
    <published>2013-03-20T06:45:07.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间陆续看了几个框架的源码，没有运用到实际项目中，确实体会不出其中的精髓。看了玉伯的一篇文章，一些看法自己比较认同，之后需要稍稍调整一下方向。</p><p>原文地址：<a href="https://github.com/lifesinger/lifesinger.github.com/issues/126" target="_blank" rel="external">https://github.com/lifesinger/lifesinger.github.com/issues/126</a><br><a id="more"></a><br><strong>奇怪的现象</strong><br>平时工作，时不时能听到一些困惑、感慨：</p><blockquote><p>jQuery 虽好，但只会 jQuery，不会原生 JS 是不被大公司认可的。</p><p>最近半年对原生 JS 有些生疏，得补一补。</p><p>得好好看看 ECMAScript 规范，把 JS 语言学透彻。<br>和原生情结对应的，是国内程序员特别喜欢研读源码，比如：</p></blockquote><ul><li>jQuery 源码分析系列</li><li>YUI 源码分析</li><li><p>Backbone 及 Underscore 源码解析<br>简言之，国内与国外相比，有比较明显的两个特点：</p></li><li><p>对原生 JS 的学习心更强。</p></li><li>对类库、框架的源码更感兴趣。<br><strong>语言高手们</strong><br>真正的语言高手不多，我不是，正在看这篇文章的你，很可能也不是，而且这一辈子可能都和我一样成为不了语言高手。<br>工作中，我们需要语言高手吗？肯定的说，需要！可是，我们需要大量语言高手吗？除了特殊岗位，我相信很多公司都不需要！<br><strong>我们的价值在哪</strong><br>除了重新投胎，我们大部分人这辈子都不大可能有兴趣、有能力、有机缘去成为 BE 大神了。这是个残酷的现实，之所以残酷，只因视野太狭窄。<br>Douglas Crockford 的 JS 能力很可能不及 winter，但 Douglas 规范并布道了 JSON 格式，天下留名，惠泽全球。<br>Jeremy Ashkenas 的 JS 能力可能还不如老赵，但 Jeremy 用很裸的代码写就了 Backbone，至少影响了一万人，给各个公司创造的价值总额很可能过千万美刀。<br>更不用说 Isaac Z. Schlueter，这小伙的 JS 功力很可能还不如我，但 Isaac 打造了 npm 生态圈，而我至今只有精力玩玩 Ant 和 Grunt。<br>有幸还看过 Google Docs 的前端源码，那代码和 Java 一样中规中矩。但在 RTE 领域，Google Docs 是王者，里面的专利都一堆一堆的……<br>特别想提及的还有开发 Evernote Clearly 的前端工程师，这小伙子的代码，我眼睁睁看着其从很生涩的 JS 代码，逐步演化成上万行牛逼代码还保持了相当好的可维护性。这份代码就像 Clearly 产品一样奕奕生光。<br>以及把 jQuery 用得出神入化的 Amazon！前不久那个秒杀国内互联网公司的悬浮菜单，可不是研究原生 JS 能想出来的。<br>还有 Facebook 的工程师们，Twitter 的工程师们…… 这些故事大家并不陌生。<br><strong>不是总结的总结</strong><br>不贬低语言高手们，也不反对去研究编译原理、ECMAScript 规范等。作为技术人员，我们需要这种精神。但是，这仅仅是很小很小很小很小很小的一个领域。并且在这个领域里，永远有比你更聪明的人。<br>具体对 JavaScript 语言来说，会用就好。搞清楚数据类型、作用域、闭包、原型链等基本概念，足矣。再深入进去，对绝大部分人来说，除了能满足下心理上的优越感，对实际工作不会有任何实质性帮助。<br>语言的本质和互联网一样，只是工具，是剪刀、石头、布。让张小泉去研究怎么做剪刀就好，我们用好剪头，去剪出各种窗花，更有意思。还有一个有趣的事实是，张小泉会造剪头，但剪不好窗花。<br>跳出很小很小很小很小很小的语言领域之外，天大地大。永远不要妄自菲薄，每个人身上都背负着独特的使命。去努力寻找自己的，不要老盯着别人的，否则就会成为观众。</li></ul><p>好像跑题了。前面那个奇怪的现象，还有很多想吐槽的点。比如<br>1.源码只是很小很小的一部分。直接读源码往往无法领会类库框架的精髓。不读源码，用心去用，用时间去体味，偶尔针对性看看源码，往往更能掌握一个类库框架的真谛。<br>2.对社区的贡献可以有很多很多。你的使用经验、用心的 bug 提交、入乡随俗的 pull request、一个认真的评论等等，这些都比去研究什么狗屁源码更有价值。<br>3.一个 Java 高手如果说他会原生 Java，那一定会遭来很多人的围观。我还会谭浩强教我的 C 呢，那几个 if else 还有结构体、指针等谁不会。语言之外的领域知识，才真正造就了高手。对于前端来说，会原生 JS 只能打 20 分，另外 40 分需要你深入使用 CSS、DOM、HTML5 等领域知识，还有 20 分需要你对业务需求、架构设计等有真正的运用，这已经 80 分了，不要太贪心。剩下 20 分，只有两个字：勤奋。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间陆续看了几个框架的源码，没有运用到实际项目中，确实体会不出其中的精髓。看了玉伯的一篇文章，一些看法自己比较认同，之后需要稍稍调整一下方向。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://github.com/lifesinger/lifesinger.github.com/issues/126&quot;&gt;https://github.com/lifesinger/lifesinger.github.com/issues/126&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>ECMA-262-3详解之闭包</title>
    <link href="http://yoursite.com/2012/10/20/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8b-e9-97-ad-e5-8c-85/"/>
    <id>http://yoursite.com/2012/10/20/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8b-e9-97-ad-e5-8c-85/</id>
    <published>2012-10-20T03:07:39.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMA-262-3详解(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail</a>)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。</p><p>在ECMAScript中，函数不仅可以作为参数，还可以作为返回值。这种特性在传统的面向堆栈的编程结构模型中，会受到很大限制。在面向堆栈的编程语言中，函数的本地变量都是保存在堆栈上的，每当函数激活的时候，这些变量和函数参数都会压栈到该堆栈上。当函数返回的时候，这些参数又会从堆栈中移除。</p><pre class="javascript">    function testFn() {        var localVar = 10;        function innerFn(innerParam) {            alert(innerParam + localVar);        }        return innerFn;    }    var someFn = testFn();    someFn(20); // 30</pre>上面的例子中，对于innerFn函数来说， localVar属于自由变量(既不是函数参数也不是函数的局部变量的变量)。在采用面向堆栈模型来存储局部变量的系统里，当testFn函数调用结束后，其局部变量会从堆栈中移除。这样当从外部对innerFn进行函数调用时，会发生错误(因为localVar变量已经不存在了)。为了解决上述问题，引入了闭包的概念。<a id="more"></a>### 闭包**闭包**是代码块和创建该代码块时上下文中数据的结合。_代码块一般指函数，这样闭包可理解为封闭了外部函数作用域中变量的内部函数。如果外部函数不返回这个内部函数，闭包的特性无法显现；如果外部函数返回这个内部函数，那么返回的内部函数就成了名副其实的闭包。此时，闭包封闭的外部变量就是自由变量，而由于该自由变量存在，外部函数即便返回，其占用的内存也得不到释放。(编注，引自["理解JavaScript 闭包"](http://www.cn-cuckoo.com/2007/08/01/understand-javascript-closures-72.html#clFrmC))_<pre class="javascript">    var x = 20;    function foo() { alert(x); // 自由变量"x" == 20 }    // foo的闭包    fooClosure = {        call: foo // 对函数的引用        lexicalEnvironment: {x: 20} // 查询自由变量的上下文    };</pre>从技术角度来说，创建该函数的上层上下文的数据是保存在函数的内部属性[[Scope]]中的。<pre class="javascript">    var x = 20;    function foo() { alert(x); }    // foo is a closure    foo: FunctionObject = {        [[Call]]: code block of foo,        [[Scope]]: [ global: { x: 20 } ],        ... // other properties    };</pre>出于优化的目的，当函数不使用自由变量的时候，实现层可能就不会保存上层作用域链。ECMAScript标准中并未对此作任何说明。这里还要注意的是：在ECMAScript中，同一个上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，某个闭包对其中的变量做修改会影响到其他闭包对其变量的读取：<pre class="javascript">    var firstClosure;    var secondClosure;    function foo() {        var x = 1;        firstClosure = function () { return ++x; };        secondClosure = function () { return --x; };        x = 2; // 对AO["x"]产生了影响, 其值在两个闭包的[[Scope]]中        alert(firstClosure()); // 3, 通过firstClosure.[[Scope]]    }    foo();    alert(firstClosure()); // 4    alert(secondClosure()); // 3</pre><p>对于闭包的分析就到这里。我们再次从理论和实践角度分别归纳一下ECMAScrip的闭包：<br>从理论角度，所有的函数都是闭包。 因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量（保存在最外层的作用域中）。<br>从实践角度，当函数满足一定的条件才算是闭包：即便创建它的上下文已经销毁，但它仍然存在（比如，内部函数从父函数中返回）；在代码中引用了自由变量。</p><p></p><h3>结论<p></p><p>闭包是ECMAScript最强大的特性之一，希望本文能够帮助您理解相关知识。<br>对于分析闭包工作机制中涉及到的执行环境上下文、作用域链等概念，可以参考本站的<a href="http://phped.sinaapp.com/?p=170" target="_blank" rel="external">“ECMA-262-3详解之执行上下文和作用域链”</a>。</p></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMA-262-3详解(&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&quot;&gt;ECMA-262-3 in detail&lt;/a&gt;)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。&lt;/p&gt;
&lt;p&gt;在ECMAScript中，函数不仅可以作为参数，还可以作为返回值。这种特性在传统的面向堆栈的编程结构模型中，会受到很大限制。在面向堆栈的编程语言中，函数的本地变量都是保存在堆栈上的，每当函数激活的时候，这些变量和函数参数都会压栈到该堆栈上。当函数返回的时候，这些参数又会从堆栈中移除。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
    function testFn() {
        var localVar = 10;
        function innerFn(innerParam) {
            alert(innerParam + localVar);
        }
        return innerFn;
    }
    var someFn = testFn();
    someFn(20); // 30
&lt;/pre&gt;
上面的例子中，对于innerFn函数来说， localVar属于自由变量(既不是函数参数也不是函数的局部变量的变量)。
在采用面向堆栈模型来存储局部变量的系统里，当testFn函数调用结束后，其局部变量会从堆栈中移除。
这样当从外部对innerFn进行函数调用时，会发生错误(因为localVar变量已经不存在了)。
为了解决上述问题，引入了闭包的概念。
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="ECMAScript" scheme="http://yoursite.com/tags/ECMAScript/"/>
    
      <category term="closure" scheme="http://yoursite.com/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3详解之执行上下文和作用域链</title>
    <link href="http://yoursite.com/2012/10/19/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8b-e6-89-a7-e8-a1-8c-e4-b8-8a-e4-b8-8b-e6-96-87-e5-92-8c-e4-bd-9c-e7-94-a8-e5-9f-9f-e9-93-be/"/>
    <id>http://yoursite.com/2012/10/19/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8b-e6-89-a7-e8-a1-8c-e4-b8-8a-e4-b8-8b-e6-96-87-e5-92-8c-e4-bd-9c-e7-94-a8-e5-9f-9f-e9-93-be/</id>
    <published>2012-10-19T08:05:22.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMA-262-3详解(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail</a>)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。</p><h3 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h3><p>执行上下文可以理解为代码块的执行环境，代码在执行的过程中需要的变量都在这个执行环境中读取。<br>一系列活动的执行上下文从逻辑上形成一个栈ECStack。 栈底总是全局上下文，栈顶是当前（活动的）执行上下文。<br>函数代码开始执行，当前执行上下文会被压入ECStack；函数返回，退出当前活动的执行上下文时，ECStack就令相应的执行上下文出栈。<br><a id="more"></a></p><h3 id="变量对象-Variable-Object"><a href="#变量对象-Variable-Object" class="headerlink" title="变量对象(Variable Object)"></a>变量对象(Variable Object)</h3><p>我们定义“变量对象”这个概念，它同执行上下文息息相关，用来保存代码中的变量声明（var）, 函数声明（FD), 函数形参（function arguments）。</p><pre class="javascript">    var a = 10;    function test(x) {      var b = 20;    };    test(30);    // 全局上下文中的变量对象    VO(globalContext) = {      a: 10,      test:    };    // “test”函数上下文中的变量对象    VO(test functionContext) = {      x: 30,      b: 20    };</pre>注意：变量对象只是一个抽象的概念，在实际执行上下文中，VO可能完全不叫VO，并且初始的结构也可能完全不同。#### 全局上下文中的变量对象全局对象是一个在进入任何执行上下文前就创建出来的对象。该对象以单例形式存在，它的属性在程序任何地方都可以直接访问，其生命周期随着程序的结束而终止。全局上下文的变量对象就是全局对象本身：<pre class="javascript">    VO(globalContext) === global;</pre><h4 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h4><p>在函数的执行上下文中，VO是不能直接访问的，它的作用由活跃对象（activation object，简称：AO）担当。</p><pre class="javascript">    VO(functionContext) === AO;</pre>活跃对象会在进入函数上下文的时候创建出来，初始化的时候会创建一个arguments属性，其值就是Arguments对象：<pre class="javascript">    AO = {        arguments:{}    };</pre><h4 id="处理上下文代码的两个阶段"><a href="#处理上下文代码的两个阶段" class="headerlink" title="处理上下文代码的两个阶段"></a>处理上下文代码的两个阶段</h4><p>处理执行上下文代码分为两个阶段：</p><ol><li>进入执行上下文</li><li>执行代码<br>对变量对象的修改和这两个阶段密切相关。<br>要注意的是，这两个处理阶段是通用的行为，与上下文类型无关（不管是全局上下文还是函数上下文都是一致的）。</li></ol><p><strong>进入执行上下文</strong><br>一旦进入执行上下文（在执行代码之前），VO就会被一些属性填充（在此前已经描述过了）：<br>•函数的形参<br>——变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined<br>•函数声明<br>——变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值<br>•变量声明<br>——变量对象的一个属性，其属性名即为变量名，其值为undefined ;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。</p><p>看下面这个例子：</p><pre class="javascript">    function test(a, b) {      var c = 10;      function d() {}      var e = function _e() {};      (function x() {});    }    test(10); // call    //进入执行上下文    AO(test) = {      a: 10,      b: undefined,      c: undefined,      d: reference to FunctionDeclaration "d"      e: undefined    };</pre>**代码执行**到了执行代码阶段，AO/VO就会修改成为如下形式：<pre class="javascript">    AO['c'] = 10;    AO['e'] = reference to FunctionExpression "_e"</pre><p>针对进入执行上下文VO属性填充的特殊情况的示例：</p><pre class="javascript">    alert(x); // function    var x = 10;    alert(x); // 10    x = 20;    function x() {};    alert(x); // 20    //进入执行上下文    VO = {};    // 发现var x = 10;    // 如果函数“x”还未定义    // 则 "x" 为undefined, 但是，在我们的例子中    // 变量声明并不会影响同名的函数值    VO['x'] = 引用了函数声明“x”    //执行代码，VO相继被修改    VO['x'] = 10;    VO['x'] = 20;</pre><h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><p>作用域链是一条变量对象的链，它和执行上下文有关，用于在标识符解析时候进行变量查询。<br>函数上下文的作用域链在函数调用的时候创建出来，它包含了活跃对象和该函数的内部[[Scope]]属性。</p><pre>    activeExecutionContext = {        VO: {...}, // or AO        this: thisValue,        Scope: [ // list of all variable objects ]    };    Scope = AO + [[Scope]]</pre>函数的内部属性[[Scope]]提供了访问更高层上下文变量对象的机制。它是函数的属性，在函数创建时保存在函数中，包含了所有上层变量对象。<pre class="javascript">    /*示例代码*/    var x = 10;    function foo() {      var y = 20;      function bar() {        var z = 30;        alert(x +  y + z);      }      bar();    }    foo();    /*标识符解析说明*/    //Variable object of the global context    globalContext.VO === Global = {      x: 10      foo: reference to function    };    //At “foo” creation, the [[Scope]] property of “foo”    foo.[[Scope]] = [      globalContext.VO    ];    //At “foo” activation    fooContext.AO = {      y: 20,      bar: reference to function    };    //And the scope chain of “foo” context is:    fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.:    fooContext.Scope = [      fooContext.AO,      globalContext.VO    ];    //At creation of inner “bar” function its [[Scope]] is:    bar.[[Scope]] = [      fooContext.AO,      globalContext.VO    ];    //At “bar” activation, the activation object of “bar” context is:    barContext.AO = {      z: 30    };    //And the scope chain of “bar” context is:    barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.:    barContext.Scope = [      barContext.AO,      fooContext.AO,      globalContext.VO    ];    //Identifier resolution for “x”, “y” and “z” names:    "x"    barContext.AO // not found    fooContext.AO // not found    globalContext.VO // found - 10    "y"    barContext.AO // not found    fooContext.AO // found - 20    "z"    barContext.AO // found - 30</pre>注意：[[Scope]]是在函数创建的时候保存起来的——静态的（不变的），只有一次并且一直都存在——直到函数销毁。<pre class="javascript">    var x = 10;    function foo() {      alert(x);    }    (function () {      var x = 20;      foo(); // 10, but not 20    })();</pre><p>ECMAScript中，在运行时，执行代码阶段有两种语句可以修改作用域链—— with语句和catch从句。<br>在标识符查询阶段，这两者都会被添加到作用域链的最前面。<br>比如，当有with或者catch的时候，作用域链就会被修改如下形式：</p><pre class="javascript">    Scope = withObject|catchObject + AO|VO + [[Scope]]</pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了几乎所有与执行上下文相关的概念以及相应的细节，建议可以对照ECMAScript规范进行更深入的学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMA-262-3详解(&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&quot;&gt;ECMA-262-3 in detail&lt;/a&gt;)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。&lt;/p&gt;
&lt;h3 id=&quot;执行上下文-Execution-Context&quot;&gt;&lt;a href=&quot;#执行上下文-Execution-Context&quot; class=&quot;headerlink&quot; title=&quot;执行上下文(Execution Context)&quot;&gt;&lt;/a&gt;执行上下文(Execution Context)&lt;/h3&gt;&lt;p&gt;执行上下文可以理解为代码块的执行环境，代码在执行的过程中需要的变量都在这个执行环境中读取。&lt;br&gt;一系列活动的执行上下文从逻辑上形成一个栈ECStack。 栈底总是全局上下文，栈顶是当前（活动的）执行上下文。&lt;br&gt;函数代码开始执行，当前执行上下文会被压入ECStack；函数返回，退出当前活动的执行上下文时，ECStack就令相应的执行上下文出栈。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="ECMAScript" scheme="http://yoursite.com/tags/ECMAScript/"/>
    
      <category term="Execution Context" scheme="http://yoursite.com/tags/Execution-Context/"/>
    
      <category term="Scope Chain" scheme="http://yoursite.com/tags/Scope-Chain/"/>
    
      <category term="Variable Object" scheme="http://yoursite.com/tags/Variable-Object/"/>
    
  </entry>
  
  <entry>
    <title>ECMA-262-3详解之this关键字</title>
    <link href="http://yoursite.com/2012/10/18/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8bthis-e5-85-b3-e9-94-ae-e5-ad-97/"/>
    <id>http://yoursite.com/2012/10/18/ecma-262-3-e8-af-a6-e8-a7-a3-e4-b9-8bthis-e5-85-b3-e9-94-ae-e5-ad-97/</id>
    <published>2012-10-18T08:00:22.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECMA-262-3详解(<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail</a>)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。</p><p>很多程序员一看到this关键字，就会把它和面向对象的编程方式联系在一起，即this指向利用构造器新创建出来的对象。<br>在ECMAScript中，this不仅仅只用来表示创建出来的对象。<br>事实上， this这块的内容非常的复杂，它在不同执行上下文的情况下其值都会不同。<br><a id="more"></a><br>下面就来详细对其进行介绍:</p><h3 id="全局代码中this的值"><a href="#全局代码中this的值" class="headerlink" title="全局代码中this的值"></a>全局代码中this的值</h3><p>这种情况下，this的值总是全局对象本身;因此，可以间接地获取引用：</p><pre class="javascript">    // 显式定义全局对象的属性    this.a = 10; // global.a = 10    alert(a); // 10    // 通过赋值给不受限的标识符来进行隐式定义    b = 20;    alert(this.b); // 20    // 通过变量声明来进行隐式定义    // 因为全局上下文中的变量对象就是全局对象本身    var c = 30;    alert(this.c); // 30</pre><h3 id="函数代码中this的值"><a href="#函数代码中this的值" class="headerlink" title="函数代码中this的值"></a>函数代码中this的值</h3><pre class="javascript">    var foo = {x: 10};        var bar = {      x: 20,      test: function () {            alert(this === bar); // true        alert(this.x); // 20              this = foo; // error, 不能更改this的值               alert(this.x); // 如果没有错误，则其值为10而不是20            }          };          // 在进入上下文的时候，this的值就确定了是“bar”对象    // 至于为什么，会在后面作详细介绍         bar.test(); // true, 20         foo.test = bar.test;          // 但是，这个时候，this的值又会变成“foo”    // 纵然我们调用的是同一个函数          foo.test(); // false, 10</pre>    一些关于JavaScript的文章和书籍中指出的“ this的值取决于函数的定义方式，如果是全局函数，则this的值就会设置为全局对象，如果是某个对象的方法，则this的值就会设置为该对象”。**这种说法并不正确。**    调用一个对象的某个方法的时候，this的值也有可能不是该对象的：<pre class="javascript">    var foo = {        bar: function () {            alert(this);            alert(this === foo);        }    };    foo.bar(); // foo, true    var exampleFunc = foo.bar;    alert(exampleFunc === foo.bar); // true    // 同样地，相同的函数以不同的调用方式，this的值也就不同了    exampleFunc(); // global, false</pre><p>那么，究竟调用表达式的方式是如何影响this的值的呢？这里有必要先介绍一种内部类型——引用类型。</p><h4 id="引用类型-The-Reference-Type"><a href="#引用类型-The-Reference-Type" class="headerlink" title="引用类型(The Reference Type)"></a>引用类型(<a href="http://bclary.com/2004/11/07/#a-8.7" target="_blank" rel="external">The Reference Type</a>)</h4><p>引用类型可以用伪代码表示</p><pre class="javascript">  Reference = {      base: <base object="">,      propertyName: <property name="">  };</property></pre>    注意引用类型(Reference)不是语言层面的数据类型数据，它纯粹是为了更好的对规范进行解释说明。**当处理一个标识符或者进行属性访问的时候**，会使用到引用类型求值。<pre class="javascript">  //引用类型求值伪代码  function GetValue(value) {       if (Type(value) != Reference) {          return value;      }       var base = GetBase(value);       if (base === null) {          throw new ReferenceError;      }       return base.[[Get]](GetPropertyName(value)); //返回对象属性实际值  }</pre><pre><code>函数上下文中this的值是函数调用者提供并且由当前调用表达式的形式而定的。如果在调用括号()的左边，是引用类型形式，那么this的值就会设置为该引用类型的base对象([GetBase](http://bclary.com/2004/11/07/#a-11.2.3))。所有其他情况下（非引用类型），this的值总是null 。由于null对于this来说没有任何意义，因此会隐式转换为全局对象。</code></pre><pre class="javascript">    //foo作为标识符    function foo() {      return this;    }    foo(); // global    var fooReference = {      base: global,      propertyName: 'foo'    };    //foo.bar属性访问    var foo = {      bar: function () {        return this;      }    };    foo.bar(); // foo    var fooBarReference = {      base: foo,      propertyName: 'bar'    };    //非引用类型    (function () {      alert(this); // null => global    })();</pre><h4 id="子函数在父函数中被调用"><a href="#子函数在父函数中被调用" class="headerlink" title="子函数在父函数中被调用"></a>子函数在父函数中被调用</h4><pre><code>这时引用类型的base对象恰好为**活跃对象(Activation Object)**，this的值是null，最终变为全局对象。</code></pre><pre class="javascript">    function foo() {      function bar() {        alert(this); // global      }      bar(); // 和AO.bar()是一样的    }</pre><h4 id="函数作为构造器被调用"><a href="#函数作为构造器被调用" class="headerlink" title="函数作为构造器被调用"></a>函数作为构造器被调用</h4><pre class="javascript">    function A() {      alert(this); // newly created object, below - "a" object      this.x = 10;    }    var a = new A();    alert(a.x); // 10</pre>    所有“A”函数中this的值会设置为新创建的对象(可以参考[javascript中new操作符](http://phped.sinaapp.com/?p=11))。#### apply和call    Function.prototype上定义了两个方法（因此，它们对所有函数而言都是可访问的），允许手动指定函数调用时this的值。    这两个方法是： apply和call ；它们都接受第一个参数作为调用上下文中this的值。    对于apply来说，第二个参数接受数组类型（或者是类数组的对象，比如arguments ）,而call方法接受任意多的参数。    这两个方法只有第一个参数是必要的——this的值。<pre class="javascript">    var b = 10;    function a(c) {      alert(this.b);      alert(c);    }    a(20); // this === global, this.b == 10, c == 20    a.call({b: 20}, 30); // this === {b: 20}, this.b == 20, c == 30    a.apply({b: 30}, [40]) // this === {b: 30}, this.b == 30, c == 40</pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文我们讨论了ECMAScript中this关键字的特性。<br>希望此文对大家理解this关键字在ECMAScript中的工作原理有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECMA-262-3详解(&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/&quot;&gt;ECMA-262-3 in detail&lt;/a&gt;)系列是学习ECMAScript不可多得的好文章。本文根据其相关章节整理得出。&lt;/p&gt;
&lt;p&gt;很多程序员一看到this关键字，就会把它和面向对象的编程方式联系在一起，即this指向利用构造器新创建出来的对象。&lt;br&gt;在ECMAScript中，this不仅仅只用来表示创建出来的对象。&lt;br&gt;事实上， this这块的内容非常的复杂，它在不同执行上下文的情况下其值都会不同。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="ECMAScript" scheme="http://yoursite.com/tags/ECMAScript/"/>
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 源码初探</title>
    <link href="http://yoursite.com/2012/09/10/jquery-e6-ba-90-e7-a0-81-e5-88-9d-e6-8e-a2/"/>
    <id>http://yoursite.com/2012/09/10/jquery-e6-ba-90-e7-a0-81-e5-88-9d-e6-8e-a2/</id>
    <published>2012-09-10T10:02:59.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/5063431/" target="_blank" rel="external">《犀利开发—jQuery内核详解与实践》</a>是一本jQuery源码分析的书籍，作者的文风以及对知识阐述的准确性一直备受质疑（如果你记得那本<a href="http://book.douban.com/subject/4007372/" target="_blank" rel="external">《JavaScript征途》</a>在51js论坛上引发的激烈讨论，没错，两本书作者是同一个人）。<br>这本书中”jQuery原型技术分解”部分却是我看过的jQuery源码分析文章中比较好的，作者的分析角度和分析过程是很值得学习的。摘录部分内容（对作者观点不同之处有删改）：<br><a id="more"></a><br>定义一个最初的jQuery类（函数）：</p><p><pre lang="javascript"><br>var jQuery = function() {    </pre></p><p>};<br><br>我们可以扩展jQuery的原型：</p><p><pre lang="javascript"><br>var jQuery = function() {};<br>jQuery.prototype = {</pre></p><p>};<br><br>jQuery的出发点是Write less, do more，对于比较长的名称可以使用短名来代替。</p><p><pre lang="javascript"><br>jQuery.fn = jQuery.prototype= { </pre></p><p>}<br>var $ = jQuery = function() {};<br><br>现在给jQuery的原型对象添加一个方法size和一个属性jquery：</p><p><pre lang="javascript"><br>var $ = jQuery = function() {};<br>jQuery.fn = jQuery.prototype = {<br>    jquery: ‘1.3.2’,<br>    size: function() {<br>        return this.length;<br>    }<br>};<br></pre><br>如何调用刚才添加的方法和属性呢？回想一下jquery的调用方式：</p><p><pre lang="javascript"><br>$(‘xxx’).jquery<br>$(‘xxx’).size();<br></pre><br>显然现在的代码并不支持这样的调用方式，我们必须先实例化jQuery类。</p><p><pre lang="javascript"><br>var $ = jQuery = function() {<br>    return new jQuery();<br>};<br></pre><br>$()与new jQuery()调用的是同一个函数，如果按以上方式实现实例化，一旦调用$()就陷入了死循环。</p><p>使用一个工厂方法来创建一个实例，把这个方法放在jQuery.prototype原型对象中, 然后在jQuery()函数中返回这个原型方法的调用，可以达到实例化的目的：</p><p><pre lang="javascript"><br>var $ = jQuery = function() {<br>    return jQuery.fn.init();<br>};<br>jQuery.fn = jQuery.prototype = {<br>    init: function() {<br>        return this;<br>    },<br>    jquery: ‘1.3.2’,<br>    size: function() {<br>        return this.length;<br>    }<br>};<br></pre><br>现在貌似已经有点jquery雏形了。</p><p>调用jQuery()结果是什么？<br>jQuery.fn.init()返回值this是jQuery.fn的一个引用，而直接对prototype操作是非常危险的。<br>为了隔离jQuery.prototype，考虑把jQuery.fn.init当作一个构造器来调用。这样jQuery.fn.init中的this关键字则不再指向jQuery.prototype，而是一个jQuery.prototype.init实例：</p><p><pre lang="javascript"><br>var $ = jQuery = function() {<br>    return new jQuery.fn.init();<br>};<br></pre><br>此时jQuery.fn.init()返回的是一个”空”对象，是访问不到jQuery.prototype成员的，我们还要做下面的处理：</p><p><pre lang="javascript"><br>jQuery.fn.init.prototype = jQuery.fn;<br></pre><br>这样new jQuery.fn.init()创建出来的对象拥有init构造器prototype的方法，其指向又是jQuery的prototype，因此创建的对象就拥有了jQuery原型中定义的方法了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/5063431/&quot;&gt;《犀利开发—jQuery内核详解与实践》&lt;/a&gt;是一本jQuery源码分析的书籍，作者的文风以及对知识阐述的准确性一直备受质疑（如果你记得那本&lt;a href=&quot;http://book.douban.com/subject/4007372/&quot;&gt;《JavaScript征途》&lt;/a&gt;在51js论坛上引发的激烈讨论，没错，两本书作者是同一个人）。&lt;br&gt;这本书中”jQuery原型技术分解”部分却是我看过的jQuery源码分析文章中比较好的，作者的分析角度和分析过程是很值得学习的。摘录部分内容（对作者观点不同之处有删改）：&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="framework" scheme="http://yoursite.com/tags/framework/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Duff&#39;s Device in JavaScript</title>
    <link href="http://yoursite.com/2012/09/07/duffs-device-in-javascript/"/>
    <id>http://yoursite.com/2012/09/07/duffs-device-in-javascript/</id>
    <published>2012-09-07T09:26:10.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/5362856/" target="_blank" rel="external">高性能JavaScript</a>一书中提到了对循环进行优化，策略之一就是减少循环迭代次数。<br>“达夫设备”（Duff’s Device）通过增加每次循环中的处理工作，可以达到减少循环次数的目的。<br><a id="more"></a><br>下面的示例列举了三种方法，分别是普通循环，Duff’s Device和Fast Duff’s Device(进一步展开余数项):</p><pre lang="javascript">//Regular Loopfunction loop(iterations){    var index = 0;    var n = iterations.length;    while (n--) {        process(iterations[index++]);    }}//Duff's Devicefunction duff(){    var index = 0;    var n = iterations.length / 8;    var startAt = iterations.length % 8;    do {        switch (startAt) {            case 0:                process(iterations[index++]);            case 7:                process(iterations[index++]);            case 6:                process(iterations[index++]);            case 5:                process(iterations[index++]);            case 4:                process(iterations[index++]);            case 3:                process(iterations[index++]);            case 2:                process(iterations[index++]);            case 1:                process(iterations[index++]);        }        startAt = 0;    }while (--n > 0);}//Fast Duff's Devicefunction duff2(iterations){    var index = 0;    var n = iterations.length % 8;    while (n--) {        process(iterations[index++]);    }    n = Math.floor(iterations.length / 8);    while (n--) {        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);        process(iterations[index++]);    }}</pre><p>对于性能提升的测试可以参看<a href="http://jsperf.com/duffs-device" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/5362856/&quot;&gt;高性能JavaScript&lt;/a&gt;一书中提到了对循环进行优化，策略之一就是减少循环迭代次数。&lt;br&gt;“达夫设备”（Duff’s Device）通过增加每次循环中的处理工作，可以达到减少循环次数的目的。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Canvas width和height</title>
    <link href="http://yoursite.com/2012/09/07/canvas-width-e5-92-8cheight/"/>
    <id>http://yoursite.com/2012/09/07/canvas-width-e5-92-8cheight/</id>
    <published>2012-09-07T07:00:02.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/7069390/" target="_blank" rel="external">Core HTML5 Canvas</a>一书中建议读者使用canvas时要留意宽高的设定：</p><blockquote><p>It’s a good idea to use the canvas element’s width and height attributes to size the element, instead of using CSS. If you use CSS to size the element without also specifying the width and height attributes of the canvas element, the element size will not match the canvas’s drawing surface size, and the browser will scale the latter to fit the former, most likely resulting in surprising and unwanted effects.<br>作者提出在属性中设置canvas宽高同在css样式中设置宽高是有区别的，并相应定义了两个概念（element size和drawing surface size）。<br><a id="more"></a><br>对于canvas的宽度高度<a href="http://www.w3.org/TR/html5/the-canvas-element.html#attr-canvas-width" target="_blank" rel="external">w3网站</a>上是这样解释的：<br>The canvas element has two attributes to control the size of the coordinate space: width and height. These attributes, when specified, must have values that are valid non-negative integers. The rules for parsing non-negative integers must be used to obtain their numeric values. If an attribute is missing, or if parsing its value returns an error, then the default value must be used instead. The width attribute defaults to 300, and the height attribute defaults to 150.</p><p>The intrinsic dimensions of the canvas element equal the size of the coordinate space, with the numbers interpreted in CSS pixels. However, the element can be sized arbitrarily by a style sheet. During rendering, the image is scaled to fit this layout size.<br>总结一下上面两段话：<strong>在canvas中定义width、height跟在style中定义width和height是不同的</strong>。在属性中设置width和height会同时设置画布(drawing surface)和元素(元素)的尺寸；而style的width和height只设置了元素尺寸，画布尺寸(默认值为width:300px，height:150px)会在元素渲染完成之后做相应的拉伸，以填满整个元素尺寸。</p></blockquote><p>简单的示例代码：</p><pre lang="html"><!DOCTYPE html><html>    <head>        <title>canvas size</title>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">        <style>            #container{                width:600px;                height:300px;            }        </style>    </head>    <body>        <canvas id="container"></canvas>        <canvas id="container2" width="600px" height="300px"></canvas>    </body>    <script>        function drawLine(canvasId){            var canvas = document.getElementById(canvasId),            context = canvas.getContext("2d");            context.beginPath();            context.moveTo(0,0);            context.lineTo(100,100);            context.stroke();        }        drawLine("container");    //意外的效果        drawLine("container2");  //期望的效果    </script></html></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/7069390/&quot;&gt;Core HTML5 Canvas&lt;/a&gt;一书中建议读者使用canvas时要留意宽高的设定：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s a good idea to use the canvas element’s width and height attributes to size the element, instead of using CSS. If you use CSS to size the element without also specifying the width and height attributes of the canvas element, the element size will not match the canvas’s drawing surface size, and the browser will scale the latter to fit the former, most likely resulting in surprising and unwanted effects.&lt;br&gt;作者提出在属性中设置canvas宽高同在css样式中设置宽高是有区别的，并相应定义了两个概念（element size和drawing surface size）。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript柯里化(Curry)</title>
    <link href="http://yoursite.com/2012/08/24/javascript-e6-9f-af-e9-87-8c-e5-8c-96curry/"/>
    <id>http://yoursite.com/2012/08/24/javascript-e6-9f-af-e9-87-8c-e5-8c-96curry/</id>
    <published>2012-08-24T07:36:26.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数应用</strong><br>在一些纯粹的函数式编程语言中，对函数的描述不是被调用（called或者invoked），而是被应用（applied）。在JavaScript中也有同样的东西——我们可以使用Function.prototype.apply()来应用一个函数，因为在JavaScript中，函数实际上是对象，并且他们拥有方法。<br><a id="more"></a><br>下面是一个函数应用的例子：</p><pre lang="javascript">// define a functionvar sayHi = function (who) {    return "Hello" + (who ? ", " + who : "") + "!";};// invoke a functionsayHi('world'); // "Hello, world!"// apply a functionsayHi.apply(null, ["world "]); // "Hello, world!"</pre>从上面的例子中可以看出来，调用一个函数和应用一个函数有相同的结果。apply()接受两个参数：第一个是在函数内部绑定到this上的对象，第二个是一个参数数组，参数数组会在函数内部变成一个类似数组的arguments对象。**部分应用**调用一个函数实际上就是给它应用一堆参数，那是否能够只传一部分参数而不传全部呢？假设已经有了一个add()函数，它的工作是把x和y两个数加到一起。下面的代码片段展示了当x为5、y为4时的计算步骤：<pre lang="javascript">// for illustration purposes// not valid JavaScript// we have this functionfunction add(x, y) {    return x + y;}// and we know the argumentsadd(5, 4);// step 1 -- substitute one argumentfunction add(5, y) {    return 5 + y;}// step 2 -- substitute the other argumentfunction add(5, 4) {    return 5 + 4;}</pre>在这个代码片段中，step 1和step 2并不是有效的JavaScript代码，但是它展示了我们手工计算的过程。首先获得第一个参数的值，然后将未知的x和已知的值5替换到函数中。然后重复这个过程，直到替换掉所有的参数。step 1是一个所谓的部分应用的例子：我们只应用了第一个参数。当你执行一个部分应用的时候并不能获得结果（或者是解决方案），取而代之的是另一个函数。下面的代码片段展示了一个虚拟的partialApply()方法的用法：<pre lang="javascript">var add = function (x, y) {    return x + y;};// full applicationadd.apply(null, [5, 4]); // 9// partial applicationvar newadd = add.partialApply(null, [5]);// applying an argument to the new functionnewadd.apply(null, [4]); // 9</pre>正如你所看到的一样，部分应用给了我们另一个函数，这个函数可以在稍后调用的时候接受其它的参数。这实际上跟add(5)(4)是等价的，因为add(5)返回了一个函数，这个函数可以使用(4)来调用。让函数理解并且处理部分应用的过程，叫柯里化（Currying）。**柯里化（Currying）**柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。看一个例子：<pre lang="javascript">// a curried add// accepts partial list of argumentsfunction add(x, y) {    if (typeof y === "undefined") { // partial        return function (y) {            return x + y;        };    }    // full application    return x + y;}</pre>再看一个通用的柯里化函数：<pre lang="javascript">function schonfinkelize(fn) {    var slice = Array.prototype.slice,    stored_args = slice.call(arguments, 1);    return function () {        var new_args = slice.call(arguments),        args = stored_args.concat(new_args);        return fn.apply(null, args);    };}</pre>现在有了通用的柯里化函数，就可以做一些测试了：<pre lang="javascript">// a normal functionfunction add(x, y) {    return x + y;}// curry a function to get a new functionvar newadd = schonfinkelize(add, 5);newadd(4); // 9// another option -- call the new function directlyschonfinkelize(add, 6)(7); // 13</pre><p><strong>什么时候使用柯里化</strong><br>当你发现自己在调用同样的函数并且传入的参数大部分都相同的时候，就是考虑柯里化的理想场景了。你可以通过传入一部分的参数动态地创建一个新的函数。这个新函数会存储那些重复的参数（所以你不需要再每次都传入），然后再在调用原始函数的时候将整个参数列表补全，正如原始函数期待的那样。</p><p>（本文内容参考<a href="http://phped.sinaapp.com/?p=26" target="_blank" rel="external">《JavaScript Patterns》</a>相关章节）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;函数应用&lt;/strong&gt;&lt;br&gt;在一些纯粹的函数式编程语言中，对函数的描述不是被调用（called或者invoked），而是被应用（applied）。在JavaScript中也有同样的东西——我们可以使用Function.prototype.apply()来应用一个函数，因为在JavaScript中，函数实际上是对象，并且他们拥有方法。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="curry" scheme="http://yoursite.com/tags/curry/"/>
    
      <category term="partial application" scheme="http://yoursite.com/tags/partial-application/"/>
    
  </entry>
  
  <entry>
    <title>GeoJSON介绍</title>
    <link href="http://yoursite.com/2012/08/15/geojson-e4-bb-8b-e7-bb-8d/"/>
    <id>http://yoursite.com/2012/08/15/geojson-e4-bb-8b-e7-bb-8d/</id>
    <published>2012-08-15T02:53:37.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>GeoJSON是一种地理数据的描述格式。GeoJSON可以描述的对象包括：几何体，要素和要素集。<br>这里几何体(Geometry)的类型有我们熟悉的点(Point),线(LineString),面(Polygon), 多点(MultiPoint),多线(MultiLineString),多面( MultiPolygon)和几何体集合(GeometryCollection)。<br>要素(Feature)包含了几何体信息以及附加的一些属性信息。<br>要素集(a collection of features)即为要素的集合。</p><p>GeoJSON的结构同JSON并增加了一些约束条件：<br>GeoJSON对象<strong>必须</strong>包含一个type属性，type的值为其描述的对象(如前所述为下列选项之一：”Point”, “MultiPoint”, “LineString”, “MultiLineString”, “Polygon”, “MultiPolygon”, “GeometryCollection”, “Feature”, “FeatureCollection”)；<br>几何体(Geometry)必须包含坐标信息，要素(Feature)<strong>必须</strong>包含一个几何体信息，同时<strong>至少</strong>有一项属性信息。<br><a id="more"></a><br>GeoJSON格式示例：<br>点</p><pre lang="javascript">{ "type": "Point", "coordinates": [100.0, 0.0] }</pre>线<pre lang="javascript">{ "type": "LineString",  "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]  }</pre>面没有洞的面：<pre lang="javascript">{ "type": "Polygon",  "coordinates": [    [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]    ] }</pre>有洞的面，数组第一项是外环，其他是内环:<pre lang="javascript">{ "type": "Polygon",  "coordinates": [    [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ],    [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2] ]    ] }</pre><p>更多介绍和示例可参考<a href="http://www.geojson.org/geojson-spec.html#appendix-a-geometry-examples" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GeoJSON是一种地理数据的描述格式。GeoJSON可以描述的对象包括：几何体，要素和要素集。&lt;br&gt;这里几何体(Geometry)的类型有我们熟悉的点(Point),线(LineString),面(Polygon), 多点(MultiPoint),多线(MultiLineString),多面( MultiPolygon)和几何体集合(GeometryCollection)。&lt;br&gt;要素(Feature)包含了几何体信息以及附加的一些属性信息。&lt;br&gt;要素集(a collection of features)即为要素的集合。&lt;/p&gt;
&lt;p&gt;GeoJSON的结构同JSON并增加了一些约束条件：&lt;br&gt;GeoJSON对象&lt;strong&gt;必须&lt;/strong&gt;包含一个type属性，type的值为其描述的对象(如前所述为下列选项之一：”Point”, “MultiPoint”, “LineString”, “MultiLineString”, “Polygon”, “MultiPolygon”, “GeometryCollection”, “Feature”, “FeatureCollection”)；&lt;br&gt;几何体(Geometry)必须包含坐标信息，要素(Feature)&lt;strong&gt;必须&lt;/strong&gt;包含一个几何体信息，同时&lt;strong&gt;至少&lt;/strong&gt;有一项属性信息。&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="GIS" scheme="http://yoursite.com/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>多边形的中心</title>
    <link href="http://yoursite.com/2012/08/14/e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e4-b8-ad-e5-bf-83/"/>
    <id>http://yoursite.com/2012/08/14/e5-a4-9a-e8-be-b9-e5-bd-a2-e7-9a-84-e4-b8-ad-e5-bf-83/</id>
    <published>2012-08-14T09:51:48.000Z</published>
    <updated>2016-07-22T03:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个由 N 个顶点<em>( x<sub>i</sub> , y<sub>i</sub> )</em> 确定的不自交闭多边形的中心能如下计算:</p><p>记号 <em>( x<sub>N</sub> , y<sub>N</sub> )</em>与顶点 <em>( x<sub>0</sub> , y<sub>0</sub> )</em>相同。多边形的面积为：</p><p><dl> <dd><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/7/0/6707070e31defe1f3e5e4a7a6b044c88.png" alt="A = \frac{1}{2}\sum_{i=0}^{N-1} (x_i\ y_{i+1} - x_{i+1}\ y_i)"></dd> </dl>多边形的中心由下式给出：</p><p><dl> <dd><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/2/c/02c362b6868aa409ba4c006cf4677a3a.png" alt="C_x = \frac{1}{6A}\sum_{i=0}^{N-1}(x_i+x_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)"></dd> </dl> <dl> <dd><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/5/b/85b6bac3e9d11333a9375eec98eece01.png" alt="C_y = \frac{1}{6A}\sum_{i=0}^{N-1}(y_i+y_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)"></dd> </dl><br><a id="more"></a><br>给出javascript实现代码</p><pre lang="javascript">// Point objectfunction Point(x,y) {   this.x=x;   this.y=y;}// Contour objectfunction Contour(points) {   // an array of Point objects defining the contour   this.pts = points; }// ...add points to the contour...Contour.prototype.area = function() {   var area=0;   var pts = this.pts;   var nPts = pts.length;   var j=nPts-1;   var p1; var p2;   for (var i=0;i<npts;j=i++) {="" p1="pts[i];" p2="pts[j];" area+="p1.x*p2.y;" area-="p1.y*p2.x;" }="" area="" =2;="" return="" area;="" };="" contour.prototype.centroid="function()" var="" pts="this." pts;="" npts="pts.length;" x="0;" y="0;" f;="" j="nPts-1;" p1;="" p2;="" for="" (var="" i="0;i<nPts;j=i++)" f="p1.x*p2.y-p2.x*p1.y;" x+="(p1.x+p2.x)*f;" y+="(p1.y+p2.y)*f;" new="" point({x:="" f,y:y="" f});="" <="" pre=""><p>其他语言实现方式可以看<a href="http://paulbourke.net/geometry/polyarea/" target="_blank" rel="external">这里</a></p></npts;j=i++)></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个由 N 个顶点&lt;em&gt;( x&lt;sub&gt;i&lt;/sub&gt; , y&lt;sub&gt;i&lt;/sub&gt; )&lt;/em&gt; 确定的不自交闭多边形的中心能如下计算:&lt;/p&gt;
&lt;p&gt;记号 &lt;em&gt;( x&lt;sub&gt;N&lt;/sub&gt; , y&lt;sub&gt;N&lt;/sub&gt; )&lt;/em&gt;与顶点 &lt;em&gt;( x&lt;sub&gt;0&lt;/sub&gt; , y&lt;sub&gt;0&lt;/sub&gt; )&lt;/em&gt;相同。多边形的面积为：&lt;/p&gt;
&lt;p&gt;&lt;dl&gt; &lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/zh/math/6/7/0/6707070e31defe1f3e5e4a7a6b044c88.png&quot; alt=&quot;A = \frac{1}{2}\sum_{i=0}^{N-1} (x_i\ y_{i+1} - x_{i+1}\ y_i)&quot;&gt;&lt;/dd&gt; &lt;/dl&gt;多边形的中心由下式给出：&lt;/p&gt;
&lt;p&gt;&lt;dl&gt; &lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/zh/math/0/2/c/02c362b6868aa409ba4c006cf4677a3a.png&quot; alt=&quot;C_x = \frac{1}{6A}\sum_{i=0}^{N-1}(x_i+x_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)&quot;&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/zh/math/8/5/b/85b6bac3e9d11333a9375eec98eece01.png&quot; alt=&quot;C_y = \frac{1}{6A}\sum_{i=0}^{N-1}(y_i+y_{i+1})(x_i\ y_{i+1} - x_{i+1}\ y_i)&quot;&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;br&gt;
    
    </summary>
    
      <category term="未分类" scheme="http://yoursite.com/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
